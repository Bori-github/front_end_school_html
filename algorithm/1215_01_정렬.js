// 3. 정렬
// 3.1 선택정렬
// 직접 해보기
let 전 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 후 = [];

let 전 = [199, 22, 33, 32, 64, 72, 222, 233]; // 순회함
let 후 = [12]; // 순회 안함

let 전 = [199, 33, 32, 64, 72, 222, 233];
let 후 = [12, 22];

let 전 = [199, 33, 64, 72, 222, 233];
let 후 = [12, 22, 32];

// 코드 시작
let 입력값 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 정렬된배열 = [];

let 길이 = 입력값.length;

// 주의사항 : pop을 하면 length가 줄어든다
// for (let i; i < 입력값.length; i++) {
//   console.log(입력값.pop());
//   console.log(i);
// }

for (let i = 0; i < 길이; i++) {
  let 최솟값 = Math.min(...입력값);
  정렬된배열.push(최솟값);
  입력값.splice(입력값.indexOf(최솟값), 1);
}
// 위의 for문과 같은 동작
// !! = 부정의 부정
// while (!!입력값.toString()) {
//   let 최솟값 = Math.min(...입력값);
//   정렬된배열.push(최솟값);
//   입력값.splice(입력값.indexOf(최솟값), 1);
// }

console.log(정렬된배열); // (9) [12, 22, 32, 33, 64, 72, 199, 222, 233]

// 3.2 삽입정렬
// 자기가 들어갈 위치를 찾아감
// o(n**2)
let 전 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 후 = [];

let 전 = [22, 33, 12, 32, 64, 72, 222, 233]; // 순회 안함
let 후 = [199]; // 순회함

let 전 = [33, 12, 32, 64, 72, 222, 233];
let 후 = [22, 199];

// 코드 시작
let 입력값 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 정렬된배열 = [];
let 배열의길이 = 입력값.length;

function 삽입값이들어갈인덱스(정렬된배열, 삽입값) {
  for (const i in 정렬된배열) {
    if (삽입값 < 정렬된배열[i]) {
      return 1;
    }
  }
  return 정렬된배열.length;
}

for (let i = 0; i < 배열의길이; i++) {
  let 삽입값 = 입력값.shift();
  let 인덱스 = 삽입값이들어갈인덱스(정렬된배열, 삽입값);
  정렬된배열.splice(인덱스, 0, 삽입값);
  console.log(
    `인덱스: ${인덱스}\n삽입값: ${삽입값}\n정렬된배열: ${정렬된배열}`
  );
}

// 3.3 병합정렬
// Worst와 Best 모두 O(nLogn), 어떤 정렬보다 빠름, 동일할 수 있음

// 분할(이해를 돕기 위해 8개로 조정)
[5, 10, 66, 77],
  [54, 32, 11, 15][(5, 10)],
  [66, 77],
  [54, 32],
  [11, 15][5],
  [10],
  [66],
  [77],
  [54],
  [32],
  [11],
  [15][
    //정복(0번째끼리 비교!)
    (5, 10)
  ],
  [66, 77],
  [32, 54],
  [11, 15][(5, 10, 66, 77)],
  [11, 15, 32, 54][(5, 10, 11, 15, 32, 54, 66, 77)];

// step 1
let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];

function 병합정렬(입력배열) {
  let 입력배열의길이 = 입력배열.length;
  if (입력배열의길이 <= 1) {
    // 재귀함수이기 때문에 종료조건을 return으로 넣어준 것
    return 입력배열;
  }

  // 중간값 : 둘로 나누기 위해서
  let 중간값 = parseInt(입력배열의길이 / 2);
  // 둘로 나누고 또 병합정렬 => 재귀
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값));
  let 그룹둘 = 병합정렬(입력배열.slice(중간값));

  return `그룹하나 : ${그룹하나}\n그룹둘 : ${그룹둘}`;
}

console.log(병합정렬(입력값));

// step 2 => 최종코드
function 병합정렬(입력배열) {
  // 분할
  let 입력배열의길이 = 입력배열.length;
  let 결과값 = [];
  if (입력배열의길이 <= 1) {
    // 재귀함수이기 때문에 종료조건을 return으로 넣어준 것
    return 입력배열;
  }

  // 중간값 : 둘로 나누기 위해서
  let 중간값 = parseInt(입력배열의길이 / 2);
  // 둘로 나누고 또 병합정렬 => 재귀
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값));
  let 그룹둘 = 병합정렬(입력배열.slice(중간값));

  while (그룹하나.length != 0 && 그룹둘.length != 0) {
    if (그룹하나[0] < 그룹둘[0]) {
      결과값.push(그룹하나.shift());
    } else {
      결과값.push(그룹둘.shift());
    }
  }

  // 정복
  // 넣고 남을 값들을 위해
  while (그룹하나.length != 0) {
    결과값.push(그룹하나.shift());
  }

  while (그룹둘.length != 0) {
    결과값.push(그룹둘.shift());
  }

  // 이 결과값은 다시 병합정렬로 들어간다
  return 결과값;
}

console.log(병합정렬(입력값)); // (8) [5, 10, 11, 15, 32, 54, 66, 77]
