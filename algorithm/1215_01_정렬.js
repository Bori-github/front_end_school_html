// 3. 정렬
// 3.1 선택정렬
// 직접 해보기
let 전 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 후 = [];

let 전 = [199, 22, 33, 32, 64, 72, 222, 233]; // 순회함
let 후 = [12]; // 순회 안함

let 전 = [199, 33, 32, 64, 72, 222, 233];
let 후 = [12, 22];

let 전 = [199, 33, 64, 72, 222, 233];
let 후 = [12, 22, 32];

// 코드 시작
let 입력값 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 정렬된배열 = [];

let 길이 = 입력값.length;

// 주의사항 : pop을 하면 length가 줄어든다
// for (let i; i < 입력값.length; i++) {
//   console.log(입력값.pop());
//   console.log(i);
// }

for (let i = 0; i < 길이; i++) {
  let 최솟값 = Math.min(...입력값);
  정렬된배열.push(최솟값);
  입력값.splice(입력값.indexOf(최솟값), 1);
}
// 위의 for문과 같은 동작
// !! = 부정의 부정
// while (!!입력값.toString()) {
//   let 최솟값 = Math.min(...입력값);
//   정렬된배열.push(최솟값);
//   입력값.splice(입력값.indexOf(최솟값), 1);
// }

console.log(정렬된배열); // (9) [12, 22, 32, 33, 64, 72, 199, 222, 233]

// 3.1 선택정렬 - 메서드 최소화
// 제대로 하려면 자리 바꾸는 것까지
const arr = [199, 22, 33, 12, 32, 64, 72, 222, 233];

function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let min_index = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[min_index] > arr[j]) {
        min_index = j;
      }
    }

    // 자리바꿈
    let temp = arr[min_index];
    arr[min_index] = arr[i];
    arr[i] = temp;
  }

  return arr;
}

console.log(selectionSort(arr)); // (9) [12, 22, 32, 33, 64, 72, 199, 222, 233]

// 3.2 삽입정렬
// 자기가 들어갈 위치를 찾아감
// o(n**2)
let 전 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 후 = [];

let 전 = [22, 33, 12, 32, 64, 72, 222, 233]; // 순회 안함
let 후 = [199]; // 순회함

let 전 = [33, 12, 32, 64, 72, 222, 233];
let 후 = [22, 199];

// 코드 시작
let 입력값 = [199, 22, 33, 12, 32, 64, 72, 222, 233];
let 정렬된배열 = [];
let 배열의길이 = 입력값.length;

function 삽입값이들어갈인덱스(정렬된배열, 삽입값) {
  for (const i in 정렬된배열) {
    if (삽입값 < 정렬된배열[i]) {
      return 1;
    }
  }
  return 정렬된배열.length;
}

for (let i = 0; i < 배열의길이; i++) {
  let 삽입값 = 입력값.shift();
  let 인덱스 = 삽입값이들어갈인덱스(정렬된배열, 삽입값);
  정렬된배열.splice(인덱스, 0, 삽입값);
  console.log(
    `인덱스: ${인덱스}\n삽입값: ${삽입값}\n정렬된배열: ${정렬된배열}`
  );
}

// 3.3 병합정렬
// Worst와 Best 모두 O(nLogn), 어떤 정렬보다 빠름, 동일할 수 있음

// 분할(이해를 돕기 위해 8개로 조정)
[5, 10, 66, 77],
  [54, 32, 11, 15][(5, 10)],
  [66, 77],
  [54, 32],
  [11, 15][5],
  [10],
  [66],
  [77],
  [54],
  [32],
  [11],
  [15][
    //정복(0번째끼리 비교!)
    (5, 10)
  ],
  [66, 77],
  [32, 54],
  [11, 15][(5, 10, 66, 77)],
  [11, 15, 32, 54][(5, 10, 11, 15, 32, 54, 66, 77)];

// step 1
let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];

function 병합정렬(입력배열) {
  let 입력배열의길이 = 입력배열.length;
  if (입력배열의길이 <= 1) {
    // 재귀함수이기 때문에 종료조건을 return으로 넣어준 것
    return 입력배열;
  }

  // 중간값 : 둘로 나누기 위해서
  let 중간값 = parseInt(입력배열의길이 / 2);
  // 둘로 나누고 또 병합정렬 => 재귀
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값));
  let 그룹둘 = 병합정렬(입력배열.slice(중간값));

  return `그룹하나 : ${그룹하나}\n그룹둘 : ${그룹둘}`;
}

console.log(병합정렬(입력값));

// step 2 => 최종코드
function 병합정렬(입력배열) {
  // 분할
  let 입력배열의길이 = 입력배열.length;
  let 결과값 = [];
  if (입력배열의길이 <= 1) {
    // 재귀함수이기 때문에 종료조건을 return으로 넣어준 것
    return 입력배열;
  }

  // 중간값 : 둘로 나누기 위해서
  let 중간값 = parseInt(입력배열의길이 / 2);
  // 둘로 나누고 또 병합정렬 => 재귀
  let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값));
  let 그룹둘 = 병합정렬(입력배열.slice(중간값));

  while (그룹하나.length != 0 && 그룹둘.length != 0) {
    if (그룹하나[0] < 그룹둘[0]) {
      결과값.push(그룹하나.shift());
    } else {
      결과값.push(그룹둘.shift());
    }
  }

  // 정복
  // 넣고 남을 값들을 위해
  while (그룹하나.length != 0) {
    결과값.push(그룹하나.shift());
  }

  while (그룹둘.length != 0) {
    결과값.push(그룹둘.shift());
  }

  // 이 결과값은 다시 병합정렬로 들어간다
  return 결과값;
}

console.log(병합정렬(입력값)); // (8) [5, 10, 11, 15, 32, 54, 66, 77]

// 3.4 퀵정렬(best - O(nlog2n), worst - O(n**2))
// 피봇값(pivot)을 기준으로 정렬(피봇값은 처음값, 중간값, 마지막 값)
// 실무에서는 worst일 경우를 피하기 위해 피봇을 랜덤하게 주는 경우나, 피봇을 2개 사용하는 경우도 있음.
let 입력값 = [66, 77, 54, 32, 10, 5, 11, 15];

//피봇값 : 66
[54, 32, 10, 5, 11, 15] +
  [66] +
  [77][
    //피봇값 : 54(66과 77은 값이 한 개이기 때문에 더이상 재귀로 호출되지 않음.)
    (32, 10, 5, 11, 15)
  ],
  [54] +
    [66] +
    [77][
      //피봇값 : 32
      (10, 5, 11, 15)
    ],
  [32] +
    [54] +
    [66] +
    [77][//피봇값 : 10
    5] +
    [10],
  [11, 15] +
    [32] +
    [54] +
    [66] +
    [77][//피봇값 : 11
    5] +
    [10] +
    [11] +
    [15] +
    [32] +
    [54] +
    [66] +
    [77];

// 코드 시작
let 입력값 = [66, 77, 54, 32, 10, 5, 11, 15];

function 퀵정렬(입력배열) {
  let 입력배열의길이 = 입력배열.length;

  if (입력배열의길이 <= 1) {
    return 입력배열;
  }

  // 피벗값 : 기준점
  let 피벗값 = [입력배열.shift()];
  let 그룹하나 = [];
  let 그룹둘 = [];

  for (let i in 입력배열) {
    if (입력배열[i] < 피벗값) {
      그룹하나.push([입력배열[i]]);
    } else {
      그룹둘.push([입력배열[i]]);
    }
  }

  console.log(`그룹하나 : ${그룹하나}\n그룹둘 : ${그룹둘}\n피벗값 : ${피벗값}`);
  return 퀵정렬(그룹하나).concat(피벗값, 퀵정렬(그룹둘));
}

console.log(퀵정렬(입력값));
